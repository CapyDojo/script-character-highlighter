<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Script Character Highlighter</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; background: #f9fafb; }
        .container { max-width: 48rem; margin: 0 auto; padding: 2rem; }
        .card { background: white; border-radius: 0.5rem; box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1); padding: 2rem; }
        h1 { font-size: 1.875rem; font-weight: bold; color: #1f2937; margin-bottom: 0.5rem; }
        .subtitle { color: #6b7280; margin-bottom: 1.5rem; }
        .form-group { margin-bottom: 1.5rem; }
        label { display: block; font-size: 0.875rem; font-weight: 500; color: #374151; margin-bottom: 0.5rem; }
        .dropzone {
            border: 2px dashed #d1d5db;
            border-radius: 0.5rem;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: #f9fafb;
        }
        .dropzone:hover { border-color: #3b82f6; background: #eff6ff; }
        .dropzone.drag-over { border-color: #3b82f6; background: #dbeafe; }
        .dropzone-icon { font-size: 3rem; margin-bottom: 0.5rem; }
        .dropzone-text { color: #6b7280; font-size: 0.875rem; }
        .dropzone-text strong { color: #3b82f6; }
        .file-info { margin-top: 0.5rem; padding: 0.75rem; background: #f0fdf4; border-radius: 0.5rem; color: #166534; font-size: 0.875rem; }
        input[type="file"] { display: none; }
        select { display: block; width: 100%; padding: 0.5rem 0.75rem; border: 1px solid #d1d5db; border-radius: 0.5rem; font-size: 0.875rem; }
        select:focus { outline: none; border-color: #3b82f6; ring: 2px; ring-color: #3b82f6; }
        button { width: 100%; background: #3b82f6; color: white; padding: 0.75rem 1rem; border: none; border-radius: 0.5rem; font-weight: 600; cursor: pointer; transition: background 0.2s; }
        button:hover:not(:disabled) { background: #2563eb; }
        button:disabled { background: #9ca3af; cursor: not-allowed; }
        .status { margin-top: 1rem; padding: 1rem; border-radius: 0.5rem; }
        .status.error { background: #fef2f2; color: #991b1b; }
        .status.success { background: #f0fdf4; color: #166534; }
        .instructions { margin-top: 2rem; padding: 1rem; background: #f9fafb; border-radius: 0.5rem; }
        .instructions h3 { font-weight: 600; color: #1f2937; margin-bottom: 0.5rem; }
        .instructions ol { margin-left: 1.5rem; }
        .instructions li { margin-top: 0.25rem; font-size: 0.875rem; color: #6b7280; }
    </style>
</head>
<body class="bg-gray-50">
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useRef } = React;

        function App() {
            const [file, setFile] = useState(null);
            const [characters, setCharacters] = useState([]);
            const [selectedCharacter, setSelectedCharacter] = useState('');
            const [highlightColor, setHighlightColor] = useState('yellow');
            const [processing, setProcessing] = useState(false);
            const [status, setStatus] = useState('');
            const [statusType, setStatusType] = useState('success');
            const [isDragging, setIsDragging] = useState(false);
            const fileInputRef = useRef(null);

            const parseDocx = async (file) => {
                setProcessing(true);
                setStatus('Reading document...');
                setStatusType('success');
                
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const zip = await JSZip.loadAsync(arrayBuffer);
                    const xmlContent = await zip.file('word/document.xml').async('string');
                    
                    // Parse XML to find character names
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlContent, 'text/xml');
                    const textNodes = xmlDoc.getElementsByTagName('w:t');
                    
                    const foundCharacters = new Set();
                    for (let i = 0; i < textNodes.length; i++) {
                        const text = textNodes[i].textContent.trim();
                        // Look for character names (ALL CAPS, short length, common script format)
                        if (text.match(/^[A-Z][A-Z\s']+$/) && text.length > 2 && text.length < 50) {
                            // Remove common script elements
                            const cleaned = text.replace(/\s*\(CONT'?D\)\s*/gi, '').trim();
                            if (cleaned.length > 2) {
                                foundCharacters.add(cleaned);
                            }
                        }
                    }
                    
                    const sortedCharacters = Array.from(foundCharacters).sort();
                    setCharacters(sortedCharacters);
                    setStatus(`Found ${sortedCharacters.length} potential characters`);
                    setStatusType('success');
                    setProcessing(false);
                } catch (error) {
                    setStatus(`Error reading file: ${error.message}`);
                    setStatusType('error');
                    setProcessing(false);
                }
            };

            const processFile = (uploadedFile) => {
                if (uploadedFile && uploadedFile.name.endsWith('.docx')) {
                    setFile(uploadedFile);
                    parseDocx(uploadedFile);
                } else {
                    setStatus('Please upload a .docx file');
                    setStatusType('error');
                }
            };

            const handleFileUpload = (e) => {
                const uploadedFile = e.target.files[0];
                processFile(uploadedFile);
            };

            const handleDragEnter = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDragging(true);
            };

            const handleDragLeave = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDragging(false);
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                e.stopPropagation();
            };

            const handleDrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDragging(false);

                const droppedFile = e.dataTransfer.files[0];
                processFile(droppedFile);
            };

            const handleDropzoneClick = () => {
                fileInputRef.current.click();
            };

            const highlightCharacter = async () => {
                if (!file || !selectedCharacter) {
                    setStatus('Please select a file and character');
                    setStatusType('error');
                    return;
                }

                setProcessing(true);
                setStatus('Processing document...');
                setStatusType('success');

                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const zip = await JSZip.loadAsync(arrayBuffer);
                    const xmlContent = await zip.file('word/document.xml').async('string');
                    
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlContent, 'text/xml');
                    const paragraphs = xmlDoc.getElementsByTagName('w:p');
                    
                    let inCharacterSection = false;
                    let highlightedCount = 0;
                    
                    // Iterate through paragraphs to find and highlight character dialogue
                    for (let i = 0; i < paragraphs.length; i++) {
                        const para = paragraphs[i];
                        const textNodes = para.getElementsByTagName('w:t');
                        let paraText = '';
                        for (let j = 0; j < textNodes.length; j++) {
                            paraText += textNodes[j].textContent;
                        }
                        
                        const trimmedText = paraText.trim();
                        
                        // Check if this is the selected character's name
                        const isCharacterName = trimmedText.includes(selectedCharacter) && 
                                              trimmedText.length < 50 &&
                                              trimmedText.match(/^[A-Z]/);
                        
                        // Check if this is a different character's name
                        const isOtherCharacter = !isCharacterName && 
                                                trimmedText.match(/^[A-Z][A-Z\s']+$/) && 
                                                trimmedText.length > 2 && 
                                                trimmedText.length < 50;
                        
                        if (isCharacterName) {
                            inCharacterSection = true;
                            addHighlightToParagraph(para, xmlDoc, highlightColor);
                            highlightedCount++;
                        } else if (isOtherCharacter) {
                            inCharacterSection = false;
                        } else if (inCharacterSection && trimmedText.length > 0) {
                            addHighlightToParagraph(para, xmlDoc, highlightColor);
                            highlightedCount++;
                        }
                    }
                    
                    // Serialize the modified XML
                    const serializer = new XMLSerializer();
                    const modifiedXml = serializer.serializeToString(xmlDoc);
                    
                    // Update the zip file
                    zip.file('word/document.xml', modifiedXml);
                    
                    // Generate the new .docx file
                    const blob = await zip.generateAsync({ type: 'blob' });
                    
                    // Download the file
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = file.name.replace('.docx', `_${selectedCharacter}_highlighted.docx`);
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    setStatus(`Successfully highlighted ${highlightedCount} paragraphs for ${selectedCharacter}`);
                    setStatusType('success');
                    setProcessing(false);
                } catch (error) {
                    setStatus(`Error processing file: ${error.message}`);
                    setStatusType('error');
                    setProcessing(false);
                }
            };

            const addHighlightToParagraph = (para, xmlDoc, color) => {
                const runs = para.getElementsByTagName('w:r');
                
                for (let i = 0; i < runs.length; i++) {
                    const run = runs[i];
                    let rPr = run.getElementsByTagName('w:rPr')[0];
                    
                    if (!rPr) {
                        rPr = xmlDoc.createElementNS('http://schemas.openxmlformats.org/wordprocessingml/2006/main', 'w:rPr');
                        if (run.firstChild) {
                            run.insertBefore(rPr, run.firstChild);
                        } else {
                            run.appendChild(rPr);
                        }
                    }
                    
                    // Check if highlight already exists
                    const existingHighlight = rPr.getElementsByTagName('w:highlight')[0];
                    if (!existingHighlight) {
                        const highlight = xmlDoc.createElementNS('http://schemas.openxmlformats.org/wordprocessingml/2006/main', 'w:highlight');
                        highlight.setAttribute('w:val', color);
                        rPr.appendChild(highlight);
                    }
                }
            };

            return (
                <div style={{ minHeight: '100vh', padding: '2rem' }}>
                    <div className="container">
                        <div className="card">
                            <h1>Script Character Highlighter</h1>
                            <p className="subtitle">Upload a script and highlight a character's dialogue</p>
                            
                            <div className="form-group">
                                <label>Upload Script (.docx)</label>
                                <div 
                                    className={`dropzone ${isDragging ? 'drag-over' : ''}`}
                                    onDragEnter={handleDragEnter}
                                    onDragOver={handleDragOver}
                                    onDragLeave={handleDragLeave}
                                    onDrop={handleDrop}
                                    onClick={handleDropzoneClick}
                                >
                                    <div className="dropzone-icon">ðŸ“„</div>
                                    <div className="dropzone-text">
                                        <strong>Click to upload</strong> or drag and drop
                                        <br />
                                        .docx files only
                                    </div>
                                </div>
                                <input
                                    ref={fileInputRef}
                                    type="file"
                                    accept=".docx"
                                    onChange={handleFileUpload}
                                />
                                {file && (
                                    <div className="file-info">
                                        âœ“ {file.name}
                                    </div>
                                )}
                            </div>

                            {characters.length > 0 && (
                                <div className="form-group">
                                    <label>Select Character</label>
                                    <select
                                        value={selectedCharacter}
                                        onChange={(e) => setSelectedCharacter(e.target.value)}
                                    >
                                        <option value="">-- Choose a character --</option>
                                        {characters.map(char => (
                                            <option key={char} value={char}>{char}</option>
                                        ))}
                                    </select>
                                </div>
                            )}

                            <div className="form-group">
                                <label>Highlight Color</label>
                                <select
                                    value={highlightColor}
                                    onChange={(e) => setHighlightColor(e.target.value)}
                                >
                                    <option value="yellow">Yellow</option>
                                    <option value="green">Green</option>
                                    <option value="cyan">Cyan</option>
                                    <option value="magenta">Magenta</option>
                                    <option value="lightGray">Light Gray</option>
                                </select>
                            </div>

                            <button
                                onClick={highlightCharacter}
                                disabled={!file || !selectedCharacter || processing}
                            >
                                {processing ? 'Processing...' : 'Highlight & Download'}
                            </button>

                            {status && (
                                <div className={`status ${statusType}`}>
                                    {status}
                                </div>
                            )}

                            <div className="instructions">
                                <h3>How to use:</h3>
                                <ol>
                                    <li>Upload your script file (must be .docx format)</li>
                                    <li>Select the character whose dialogue you want to highlight</li>
                                    <li>Choose a highlight color</li>
                                    <li>Click "Highlight & Download" to get your highlighted script</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(React.createElement(App), document.getElementById('root'));
    </script>
</body>
</html>
